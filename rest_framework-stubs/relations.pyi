from typing import Any, Dict, Iterable, Optional, Protocol, Sequence

from django.db.models import Model
from django.db.models.query import QuerySet
from django.utils import six
from django.utils.translation import ugettext_lazy as _
from rest_framework.fields import Field, empty, get_attribute, iter_options
from rest_framework.request import Request
from rest_framework.settings import api_settings
from rest_framework.utils import html

def method_overridden(method_name: str, klass: type, instance: Any) -> bool: ...

class ObjectValueError(ValueError): ...
class ObjectTypeError(TypeError): ...

class Hyperlink(six.text_type):
    """
    A string like object that additionally has an associated name.
    We use this for hyperlinked URLs that may render as a named link
    in some contexts, or render as a plain URL in others.
    """

    is_hyperlink: bool = ...
    @property
    def name(self) -> str: ...

class PKOnlyObject(object):
    def __init__(self, pk: Any) -> None: ...

MANY_RELATION_KWARGS: Sequence[str] = ...

_Choices = Dict[Any, Any]

class Option(Protocol):
    start_option_group: bool = ...
    end_option_group: bool = ...

class RelatedField(Field):
    queryset: Optional[QuerySet] = ...
    html_cutoff: Optional[int] = ...
    html_cutoff_text: Optional[str] = ...
    def __new__(cls, *args, **kwargs):
        # We override this method in order to automagically create
        # `ManyRelatedField` classes instead when `many=True` is set.
        if kwargs.pop("many", False):
            return cls.many_init(*args, **kwargs)
        return super(RelatedField, cls).__new__(cls, *args, **kwargs)
    @classmethod
    def many_init(cls, *args: Any, **kwargs: Any) -> ManyRelatedField: ...
    def get_queryset(self) -> QuerySet: ...
    def use_pk_only_optimization(self) -> bool: ...
    def get_attribute(self, instance: Any) -> Any: ...
    def get_choices(self, cutoff: Optional[int] = ...) -> _Choices: ...
    @property
    def choices(self) -> _Choices: ...
    @property
    def grouped_choices(self) -> _Choices: ...
    def iter_options(self) -> Iterable[Option]: ...
    def display_value(self, instance: Any) -> str: ...

class StringRelatedField(RelatedField): ...
class PrimaryKeyRelatedField(RelatedField): ...

class HyperlinkedRelatedField(RelatedField):
    lookup_field: str = ...
    lookup_url_kwarg: str = ...
    format: Optional[str] = ...
    view_name: Optional[str] = ...
    def __init__(self, view_name: Optional[str] = ..., **kwargs: Any): ...
    def get_object(self, view_name: str, view_args: Any, view_kwargs: Any) -> Model: ...
    def get_url(self, obj: Model, view_name: str, request: Request, format: str) -> str: ...

class HyperlinkedIdentityField(HyperlinkedRelatedField): ...

class SlugRelatedField(RelatedField):

    slug_field: Optional[Field] = ...
    def __init__(self, slug_field: Optional[Field] = None, **kwargs: Any): ...

class ManyRelatedField(Field):
    """
    Relationships with `many=True` transparently get coerced into instead being
    a ManyRelatedField with a child relationship.

    The `ManyRelatedField` class is responsible for handling iterating through
    the values and passing each one to the child relationship.

    This class is treated as private API.
    You shouldn't generally need to be using this class directly yourself,
    and should instead simply set 'many=True' on the relationship.
    """

    initial = []
    default_empty_html = []
    html_cutoff: Optional[int] = ...
    html_cutoff_text: Optional[str] = ...
    def __init__(self, child_relation=None, *args, **kwargs):
        self.child_relation = child_relation
        self.allow_empty = kwargs.pop("allow_empty", True)

        cutoff_from_settings = api_settings.HTML_SELECT_CUTOFF
        if cutoff_from_settings is not None:
            cutoff_from_settings = int(cutoff_from_settings)
        self.html_cutoff = kwargs.pop("html_cutoff", cutoff_from_settings)

        self.html_cutoff_text = kwargs.pop(
            "html_cutoff_text", self.html_cutoff_text or _(api_settings.HTML_SELECT_CUTOFF_TEXT)
        )
        assert child_relation is not None, "`child_relation` is a required argument."
        super(ManyRelatedField, self).__init__(*args, **kwargs)
        self.child_relation.bind(field_name="", parent=self)
    def get_value(self, dictionary):
        # We override the default field access in order to support
        # lists in HTML forms.
        if html.is_html_input(dictionary):
            # Don't return [] if the update is partial
            if self.field_name not in dictionary:
                if getattr(self.root, "partial", False):
                    return empty
            return dictionary.getlist(self.field_name)

        return dictionary.get(self.field_name, empty)
    def get_attribute(self, instance: Any) -> Any: ...
    def get_choices(self, cutoff: Optional[int] = ...) -> _Choices: ...
    @property
    def choices(self) -> _Choices: ...
    @property
    def grouped_choices(self) -> _Choices: ...
    def iter_options(self) -> Iterable[Option]: ...
